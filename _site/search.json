[
  {
    "objectID": "chaos.html",
    "href": "chaos.html",
    "title": "Chaos Theory with DChaos library",
    "section": "",
    "text": "library(DChaos)\nlibrary(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "chaos.html#data",
    "href": "chaos.html#data",
    "title": "Chaos Theory with DChaos library",
    "section": "",
    "text": "library(DChaos)\nlibrary(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "chaos.html#state-space-reconstruction",
    "href": "chaos.html#state-space-reconstruction",
    "title": "Chaos Theory with DChaos library",
    "section": "State space reconstruction",
    "text": "State space reconstruction\n\nTaken’s Theorem\nWe use Takens’ Theorem to “unfold” a 1D time series into a multi-dimensional state space using embedding dimension and time-delays.\nTo “unfold” a time series, we need two critical parameters:\n\nTime Delay (\\(d\\)): How far apart our observations are sampled to create new dimensions. It ensures our coordinates are mathematically independent.\nEmbedding Dimension (\\(m\\)): The total number of dimensions needed to ensure the system’s trajectory doesn’t intersect itself.\n\nThe netfit function fits a neural network to this unfolded data. This isn’t for “prediction” in the traditional sense; rather, the network serves as a differentiable surrogate for the unknown physical laws governing the system. By calculating the Jacobian of this network, we can rigorously quantify chaos.\n\nmodel = netfit(btc_1d$High, m = 1:6,lag = 1:6,timelapse = \"FIXED\",h = 2:10)\njacobian = jacobian.net(model = model)\nsummary(model)"
  },
  {
    "objectID": "chaos.html#lyapunov-exponent",
    "href": "chaos.html#lyapunov-exponent",
    "title": "Chaos Theory with DChaos library",
    "section": "Lyapunov Exponent",
    "text": "Lyapunov Exponent\nThe “ultimate tool” of chaos is a Positive Maximum Lyapunov Exponent (\\(\\lambda_{max} &gt; 0\\)).\nThe DChaos package provides two main ways to find this:\nlyapunov.max(): Focuses specifically on the largest exponent to determine if the system is chaotic.\n\nexponent.max = lyapunov.max(data = jacobian, blocking = \"BOOT\",doplot = FALSE)\nsummary(exponent.max)\n\nCall:\nLargest Lyapunov exponent \n\nCoefficients:\n            Estimate Std. Error   z value     Pr(&gt;|z|)\nExponent -0.07216916 0.03391099 -20.85195 7.316176e-97\n---\nProcedure: Norma-2 by bootstrap blocking method \nEmbedding dimension: 2, Time-delay: 1, No. hidden units: 2\nSample size: 2949, Block length: 96, No. blocks: 1000\n\n\nlyapunov.spec(): Estimates the full spectrum of exponents, allowing you to calculate the Kaplan-Yorke Dimension (the fractal dimension of the attractor).\n\nexponent.spec = lyapunov.spec(data = jacobian, blocking = \"BOOT\",doplot = FALSE)\nsummary(exponent.spec)\n\nCall:\nLyapunov exponent spectrum \n\nCoefficients:\n              Estimate  Std. Error     z value     Pr(&gt;|z|)\nExponent 1 -0.07213056 0.034124864   -20.71018 1.401906e-95\nExponent 2 -2.16370134 0.006763006 -3134.67959 0.000000e+00\n---\nProcedure: QR decomposition by bootstrap blocking method \nEmbedding dimension: 2, Time-delay: 1, No. hidden units: 2\nSample size: 2949, Block length: 96, No. blocks: 1000\n\n\nBy using a neural network to estimate the Jacobian matrix, DChaos ensures that the calculation is based on the underlying functional form of the system rather than just noisy point-to-point measurements."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Guide",
    "section": "",
    "text": "Overview\nThis website collects theory-driven examples of dynamical systems implemented in R, with an emphasis on nonlinear dynamics, chaos, and predictability from time series.\nThe goal is not speed. The goal is understanding.\nStart with nonlinear dynamical systems, then move to practical tools like the DChaos library."
  },
  {
    "objectID": "chaos01.html",
    "href": "chaos01.html",
    "title": "The 0-1 Test for Chaos with Chaos01",
    "section": "",
    "text": "library(DChaos)\nlibrary(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "chaos01.html#data",
    "href": "chaos01.html#data",
    "title": "The 0-1 Test for Chaos with Chaos01",
    "section": "",
    "text": "library(DChaos)\nlibrary(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "chaos01.html#test-for-chaos",
    "href": "chaos01.html#test-for-chaos",
    "title": "The 0-1 Test for Chaos with Chaos01",
    "section": "0-1 Test for Chaos",
    "text": "0-1 Test for Chaos\nThe 0-1 Test is a binary diagnostic for determinism and chaos. While the Lyapunov Exponent asks, “How fast do nearby points diverge?”, the 0-1 Test asks, “Does the data behave like a predictable machine or like a random walk?”"
  },
  {
    "objectID": "chaos01.html#the-core-intuition",
    "href": "chaos01.html#the-core-intuition",
    "title": "The 0-1 Test for Chaos with Chaos01",
    "section": "The Core Intuition",
    "text": "The Core Intuition\nImagine taking your time series and using its values to “drive” a point on a 2D plane.\n\nIf the system is Regular (periodic), the point will move in circles or stay in a tight, bounded area.\nIf the system is Chaotic, the point will wander away from its starting position, mimicking a Brownian Motion (random walk)."
  },
  {
    "objectID": "chaos01.html#how-the-algorithm-works",
    "href": "chaos01.html#how-the-algorithm-works",
    "title": "The 0-1 Test for Chaos with Chaos01",
    "section": "2. How the Algorithm Works",
    "text": "2. How the Algorithm Works\nThe 0-1 Test avoids the complexities of phase space reconstruction by mapping the 1D time series into a 2-dimensional plane. Think of it as a “driven” system where your data acts as the steering input for a particle.\n\nStep 1: Coordinate Transformation\nGiven a time series \\(x_n\\) for \\(n = 1, 2, \\dots, N\\), we choose a constant \\(c \\in (0, \\pi)\\) and define two new coordinates, \\(p_n\\) and \\(q_n\\):\n\\[p_n = \\sum_{j=1}^{n} x_j \\cos(jc), \\quad q_n = \\sum_{j=1}^{n} x_j \\sin(jc)\\]\nThese coordinates represent a trajectory in a 2D plane (the \\((p,q)\\)-plane).\n\n\nStep 2: Mean Square Displacement (MSD)\nWe analyze how the distance from the origin grows over time. We calculate the Mean Square Displacement, denoted as \\(M_n\\):\n\\[M_n = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{j=1}^{N} [ (p_{j+n} - p_j)^2 + (q_{j+n} - q_j)^2 ]\\]\n\nIf the system is Regular: the \\((p,q)\\) trajectory stays in a bounded area (like a circle or a torus), and the \\(M_n\\) remains small and bounded.\nIf the system is Chaotic: the \\((p,q)\\) trajectory behaves like a Brownian Motion, and \\(M_n\\) grows linearly with time \\(n\\).\n\n\n\nStep 3: The Chaos Parameter (\\(K\\))\nThe final step is to determine the growth rate of \\(M_n\\). This is typically done by calculating the correlation between \\(M_n\\) and the time \\(n\\).\nThe result is the \\(K\\)-value: * \\(K \\approx 0\\): Indicates a non-chaotic (periodic or quasi-periodic) system. * \\(K \\approx 1\\): Indicates a chaotic system.\n\n\n\n\n\n\nImportantWhy it works\n\n\n\nThe 0-1 test is essentially a test for the Statistical Limit Theorem. In the periodic case, the coordinates \\(p\\) and \\(q\\) satisfy a central limit theorem type of behavior only if the system is chaotic, causing the diffusive (random walk) behavior in the \\((p,q)\\)-plane."
  },
  {
    "objectID": "dsystems.html",
    "href": "dsystems.html",
    "title": "The Theory of Dynamics and Time Series",
    "section": "",
    "text": "At its core, a Dynamical System is a mathematical description of how a point moves through a space over time. The most intuitive way to think about this is through the lens of State Space.\nA system is defined by:\n\nState Space (\\(M\\)): The manifold or set containing all possible states of the system (e.g., the position and momentum of a planet).\nEvolution Rule: A deterministic or stochastic function that dictates the future state based on the current one.\n\n\n\nIn R, we typically deal with two types of mathematical representations:\n\nContinuous-Time (Flows): Modeled by Differential Equations. We focus on the rate of change. \\[\\frac{dx}{dt} = f(x, t)\\] Used in: Physics simulations, chemical kinetics, and population models.\nDiscrete-Time (Maps): Modeled by Difference Equations. We focus on the step from one moment to the next. \\[x_{n+1} = f(x_n)\\] Used in: Financial modeling, digital signal processing, and iterative algorithms."
  },
  {
    "objectID": "dsystems.html#defining-the-dynamical-system",
    "href": "dsystems.html#defining-the-dynamical-system",
    "title": "The Theory of Dynamics and Time Series",
    "section": "",
    "text": "At its core, a Dynamical System is a mathematical description of how a point moves through a space over time. The most intuitive way to think about this is through the lens of State Space.\nA system is defined by:\n\nState Space (\\(M\\)): The manifold or set containing all possible states of the system (e.g., the position and momentum of a planet).\nEvolution Rule: A deterministic or stochastic function that dictates the future state based on the current one.\n\n\n\nIn R, we typically deal with two types of mathematical representations:\n\nContinuous-Time (Flows): Modeled by Differential Equations. We focus on the rate of change. \\[\\frac{dx}{dt} = f(x, t)\\] Used in: Physics simulations, chemical kinetics, and population models.\nDiscrete-Time (Maps): Modeled by Difference Equations. We focus on the step from one moment to the next. \\[x_{n+1} = f(x_n)\\] Used in: Financial modeling, digital signal processing, and iterative algorithms."
  },
  {
    "objectID": "dsystems.html#the-bridge-how-a-time-series-is-a-dynamical-system",
    "href": "dsystems.html#the-bridge-how-a-time-series-is-a-dynamical-system",
    "title": "The Theory of Dynamics and Time Series",
    "section": "2. The Bridge: How a Time Series is a Dynamical System",
    "text": "2. The Bridge: How a Time Series is a Dynamical System\nA Time Series is often just a “shadow” or a partial observation of a higher-dimensional dynamical system.\nIn classical statistics, we often view a series \\(Y = \\{y_1, y_2, \\dots, y_n\\}\\) as a sequence of random variables. However, in Dynamical Systems theory, we assume there is an underlying state \\(x_t\\) that evolves according to a rule, and our data \\(y_t\\) is what we managed to measure.\n\nThe Observation Projection\n\\[y_t = h(x_t) + \\epsilon_t\\]\nWhere: * \\(x_t\\) is the true state (often hidden/latent). * \\(h\\) is the measurement function (mapping the complex system to a single number). * \\(\\epsilon_t\\) is the noise (uncertainty or measurement error).\nThe key insight: If the underlying system is deterministic, we can often “reconstruct” the dynamics of the whole system just by looking at a single time series using techniques like Delay Embedding."
  },
  {
    "objectID": "dsystems.html#essential-concepts-for-analysis",
    "href": "dsystems.html#essential-concepts-for-analysis",
    "title": "The Theory of Dynamics and Time Series",
    "section": "3. Essential Concepts for Analysis",
    "text": "3. Essential Concepts for Analysis\nTo navigate the R packages on this site, it is helpful to keep these three concepts in mind:\n\n\n\n\n\n\n\nConcept\nThe “Plain English” Explanation\n\n\n\n\nAttractors\nThe “shape” the data settles into over time (e.g., a steady state, a cycle, or a strange attractor).\n\n\nPhase Space\nPlotting the system against its own derivatives or lags to see the geometry of its behavior.\n\n\nStability\nWhether a small nudge to the system returns to the original path or causes it to blow up."
  },
  {
    "objectID": "dsystems.html#why-use-r-for-this",
    "href": "dsystems.html#why-use-r-for-this",
    "title": "The Theory of Dynamics and Time Series",
    "section": "4. Why use R for this?",
    "text": "4. Why use R for this?\nR provides a unique ecosystem that bridges the gap between theoretical math and empirical data.\n\nSimulation: Use packages to solve ODEs and see how theoretical models behave.\nReconstruction: Take raw, messy time series and find the “hidden” dimensions and Lyapunov exponents.\nForecasting: Use the geometry of the past to predict the trajectory of the future.\n\n\n\n\n\n\n\nTipReady to Explore?\n\n\n\nCheck the sidebar to explore R packages categorized by Simulation, Non-linear Analysis, and Statistical Forecasting."
  },
  {
    "objectID": "fractal.html",
    "href": "fractal.html",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "",
    "text": "library(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "fractal.html#data",
    "href": "fractal.html#data",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "",
    "text": "library(readr)\n# Load the BTC data\nbtc_1d = read_csv(\"btc_1d_data_2018_to_2025.csv\")\nbtc_1d$Date = as.Date(btc_1d$`Open time`)\nbtc_1d = btc_1d[,c(\"Date\",\"High\")]"
  },
  {
    "objectID": "fractal.html#beyond-euclidean-geometry",
    "href": "fractal.html#beyond-euclidean-geometry",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "Beyond Euclidean Geometry",
    "text": "Beyond Euclidean Geometry\nIn standard geometry, we deal with integer dimensions: a point (0D), a line (1D), and a plane (2D). However, natural phenomena—like the jagged path of a stock price or the silhouette of a mountain—often exist in the “fractional” space between these integers.\nFractal Dimension (\\(D\\)) measures how a pattern’s detail changes with the scale at which it is measured. The most intuitive definition is the Scaling Law:\nIf you reduce the measurement scale by a factor of \\(L\\) and find \\(N\\) number of self-similar pieces, the dimension is: \\[D = \\frac{\\log(N)}{\\log(L)}\\]"
  },
  {
    "objectID": "fractal.html#interpreting-the-values",
    "href": "fractal.html#interpreting-the-values",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "Interpreting the Values",
    "text": "Interpreting the Values\nWhen analyzing a 1D time series, your calculated \\(D\\) will typically fall between 1.0 and 2.0. Here is how to interpret the “physics” of those numbers:\n\n\n\n\n\n\n\n\nFractal Dimension (\\(D\\))\nDescription\nVisual Texture\n\n\n\n\n\\(D \\approx 1.0\\)\nDifferentiable\nSmooth, predictable curves or straight lines.\n\n\n\\(1.2 &lt; D &lt; 1.3\\)\nLow Complexity\nGentle oscillations with minor noise.\n\n\n\\(D \\approx 1.5\\)\nBrownian Motion\nThe “Random Walk.” Unpredictable with no long-term memory.\n\n\n\\(D \\to 2.0\\)\nSpace-Filling\nExtremely “jagged” and volatile; the line moves so much it nearly fills a 2D area."
  },
  {
    "objectID": "fractal.html#the-fractaldim-library-in-r",
    "href": "fractal.html#the-fractaldim-library-in-r",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "The fractaldim Library in R",
    "text": "The fractaldim Library in R\nThe fractaldim package is the preferred tool for high-performance estimation. It provides several algorithms to calculate \\(D\\), as different methods have different sensitivities to noise and signal length.\n\nKey Estimation Methods\n\nBox-Counting (boxcount): The most famous method. It covers the signal with a grid of boxes of size \\(\\epsilon\\) and counts how many boxes are intercepted by the signal.\nVariogram (variogram): Analyzes the variance of increments. This is often the most robust method for signals that resemble stochastic processes.\nHall-Wood (hallwood): A specialized estimator designed to reduce bias in small samples or very noisy data."
  },
  {
    "objectID": "fractal.html#practical-implementation",
    "href": "fractal.html#practical-implementation",
    "title": "Fractal Dimensions with fractaldim library",
    "section": "Practical Implementation",
    "text": "Practical Implementation\nTo use this in your workflow, you generally pass a numeric vector to the fd.estimate function.\n\nlibrary(fractaldim)\n\nLoading required package: abind\n\n# Estimate the dimension using multiple methods\n# It is best practice to compare a few methods to ensure consistency\nestimate.b &lt;- fd.estimate(btc_1d$High, methods = \"boxcount\")\nestimate.v &lt;- fd.estimate(btc_1d$High, methods = \"variogram\")\n\n\n# Access the numerical results\ncat(\"Estimated D (Box-count):\", estimate.b$fd)\n\nEstimated D (Box-count): 1.413444\n\ncat(\"Estimated D (Variogram):\", estimate.v$fd)\n\nEstimated D (Variogram): 1.429565"
  }
]